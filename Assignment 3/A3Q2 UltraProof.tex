The first part of this algorithm (lines 1 - 3) will execute $3n$ steps regardless of input. This is because there are no ways for the code to halt prematurely and the for-loop in line 1 will execute the two (constant time) lines below it $n$ times and it will also check its continue condition once per iteration. \\

The second part of this algorithm (lines 4 and below) focuses on hashing each $y\in Y$ to some sub-array in $A$. The probability that the algorithm hashes $k$ many $y$ values that do not have a corresponding $x$ value to satisfy $z$ is 
equal to $\prod\limits_{j=0}^k(1-\frac{1}{n-j}) = \frac{n - k - 1}{n}$. This is because the sample space of possible $y$ values to pick from starts at $n$ and decreases by 1 with each iteration. \\

When the algorithm has selected a $y$ that satisfies $z$, the initial probability of such an $x$ value residing at any given index of the sub-array $A[h(z - y)]$ will be $\frac{1}{\alpha}$. Therefore, the initial probability of some $x$ value  not satisfying $z$ with the given $y$ is $1 - \frac{1}{\alpha}$. Let $i$ be the number of values that the algorithm needs to go through before finding the right $x$ value in the $i$-th index. The probability that the algorithm goes over this many values in $A[h(z - y)]$ that do not satisfy $z$ is $\prod\limits_{k=0}^i(1 - \frac{1}{\alpha - k})$. This product notation is needed to deal with the fact that the sample space of possible $x$ values decreases by 1 with every iteration. \\

This probability is equal to $\frac{\alpha - i - 1}{\alpha}$. Since we are considering the case where the algorithm goes over $i$ values and then finds the right $x$ value in the index right after $i$, we are guaranteed to find the right $x$ value at index $i+1$. Since this outcome is guaranteed, the probability must be 1. Therefore, in this case the probability of going through $i$ indexes before finding the right value at index $i+1$ is exactly the same as the probability of going through $i$ indexes. Therefore, the probability that the algorithm goes over $i-1$ values and finds the right $x$ value in the $i$-th index is $\frac{\alpha - (i - 1) - 1}{\alpha} = \frac{\alpha - i}{\alpha}$. \\

The number of steps executed in this situation is $2i + 3$. This is because there are $i$ many iterations executed before the $x$ is found, where each iteration contains one for-loop check and one-if-statement check, and there are 3 lines to execute once $x$ is found (for-loop check, one if-statement check and a return statement). Thus, the probability-weighted number of steps that must be executed in this case will be equal to $(2i+ 3) * \frac{\alpha - i}{\alpha}$. Therefore, the expected number of steps that the algorithm will execute while searching the sub-array $A[h(z - y)]$ (we will need to search indices 1 through $\alpha - 1$ to find $x$ if we know $x \in A[h(z - y)]$) will be equal to : \\
$\sum\limits_{i=0}^{\alpha - 1}((2i+ 3) * \frac{\alpha - i}{\alpha}) = \sum\limits_{i=0}^{\alpha - 1}((2i+ 3) * (1 -\frac{i}{\alpha})) = \frac{2\alpha^2 + 9\alpha + 7}{6}$\\

When $y$ values do not have a corresponding $x$ value, searching for $z - y$ in $A[h(z - y)]$ (where $(z - y) \not \in A[h(z - y)]$) takes $2\alpha + 1$ steps. This is because there are $\alpha$ many for-loop condition checks, $\alpha$ many if-statement checks and 1 assignment statement. In the case where $k$ many $y$ values were hashed and then searched for without fruition, $k* (2\alpha + 1)$ steps have been executed. Therefore, in the case where the algorithm hashes $(k - 1)$ $y$ values without fruition and then hashes an appropriate $y$ value, the algorithm executes the following number of steps in total: \\
$\frac{2\alpha^2 + 9\alpha + 7}{6} + (k-1)(2\alpha + 1) = \frac{2a^2 + 6k(2\alpha + 1) + 9\alpha + 7}{6}$\\

Recall the probability that the algorithm hashes $k$ many $y$ values that do not have a corresponding $x$ value to satisfy $z$ is $\frac{n - k - 1}{n}$. Thus the probability that the algorithm hashes $k-1$ many $y$ values that do not have corresponding $x$ values is $\frac{n - k - 2}{n}$. Therefore, the probability weighted number of steps that will be executed will be equal to: \\
$(\frac{n - k - 2}{n})*(\frac{2a^2 + 6k(2\alpha + 1) + 9\alpha + 7}{6}) = \frac{(2\alpha^2 + 6(2\alpha + 1)k + 9\alpha + 7)*(n - k - 2)}{6n}$ \\
$ = \frac{-2\alpha^2k + 2\alpha^2n -4\alpha^2 - 12\alpha k^2 + 12\alpha kn - 33\alpha k + 9\alpha n - 18\alpha - 6k^2 + 6kn - 19k + 7n- 14}{6n}$ \\

By summing this weighted value from $k = 1$ to $n$, we get an expected number of steps: \\
$\sum\limits_{k=1}^{n} \frac{-2\alpha^2k + 2\alpha^2n -4\alpha^2 - 12\alpha k^2 + 12\alpha kn - 33\alpha k + 9\alpha n - 18\alpha - 6k^2 + 6kn - 19k + 7n- 14}{6n}$
